#!/bin/bash

shopt -s extglob nullglob

nc=0
cron=0
fullshebang=0
lang=bash
edit=0
user_editor=0
editor=
toedit=()

# add a PATH assignment and export to the script, based on the curent PATH
# splits on colons so that the lines are truncated to 80 chars
add_path() {
  local q=\' IFS=: cur=0 path len i elements

  # split PATH (with escaped single quotes) into array on ":"
  IFS=: read -ra path <<<"${PATH//$q/\\$q}"
  elements=${#path[@]}

  # iterate over array elements, adding the lengths until the line is too long
  for ((i=0, len=0; i<=elements && len<=74; i++)); do
    ((len += ${#path[i]} + 1))
  done
  ((i--))

  # if a single element is too long, use it anyway
  if ((cur < elements && cur == i)); then
    ((i++))
  fi

  # print the assignment, with all of the elements up to "i"
  printf "PATH='%s'\n" "${path[*]:cur:i-cur}"
  # cur is the element at which the line becomes too long
  cur=$i

  # continue looping over the indices, doing the same, until PATH is exhausted
  until ((cur >= elements)); do
    for ((i=cur, len=0; len<=72 && i<=elements; i++)); do
      ((len += ${#path[i]} + 1))
    done
    ((i--))

    if ((cur < elements && cur == i)); then
      ((i++))
    fi

    printf "PATH+=':%s'\n" "${path[*]:cur:i-cur}"
    cur=$i
  done

  # print the export line
  printf "%s\n\n" 'export PATH'
}

# print error and exit
die() {
  printf '%s\n' "$@" >&2
  exit 1
}

# print error, do not exit
err() {
  printf '%s\n' "$@" >&2
}

# open editor (if user supplied), VISUAL, EDITOR, or "vi", in that order
editor() {
  if ((user_editor)); then
    $editor "$@"
  elif [[ $VISUAL ]]; then
    $VISUAL "$@"
  else
    ${EDITOR:-vi} "$@"
  fi
}

# adds '.N' to a filename, sans extension, until it doesn't exist
noclobber() {
  local out=$1 i=0

  if [[ $1 = *+([^/]).*([^/]) ]]; then
    local base=${1%.*} ext=${1##*.}
    
    while [[ -e $out ]]; do
      out=$base.$((++i)).$ext
    done
  else
    while [[ -e $out ]]; do
      out=$1.$((++i))
    done
  fi

  printf '%s\n' "$out"
}

usage() {
cat <<'EOF'
newscript [OPTIONS] NAME [...]

Creates a new script for each NAME, in the current working directory

 Options:
  -h, --help              display this help and exit
  -l, --language LANG     specify the language LANG, default is bash
  -s, --shebang SHEBANG   provide the entire shebang as an arg, SHEBANG
  -c,  --cron             add a your current PATH to the beginning of the
                          script. only available with -l bash (default), or sh
  -n, --no-clobber        prepends a number to the end of each existing NAME
                          instead of erring
  -e, --edit              open created files in a text editor
  -p, --editor PROG       use PROG instead of the default editor. by default,
                          VISUAL, EDITOR, or vi will be used, in that order.
                          implies -e (--edit)

 Available languages for LANG are:
  bash, sh, awk, sed, perl, python
EOF
}

# iterate over options breaking -ab into -a -b when needed and
# --foo=bar into --foo bar
optstring=hl:s:cnep:
while (($#)); do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      for ((i=1; i<${#1}; i++)); do
        c=${1:i:1}

        if [[ $optstring = *"$c":* ]]; then
          options+=(-"$c" "${1:2}")
          break
        else
          options+=(-"$c")
        fi
      done
      ;;

    # if option is of type --foo=bar, split on first '='
    --?*=*) options+=("${1%%=*}" "${1#*=}");;

    # otherwise, nothing special
    *) options+=("$1");;
  esac

  shift
done
# reset "$@" to "${options[@]}"
set -- "${options[@]}"
unset options

while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; exit 0;;
    -c|--cron) cron=1;;
    -n|--no-clobber) nc=1;;
    -l|--language)
      [[ $2 ]] || die "argument required for $1"
      lang=$2
      shift
      ;;
    -s|--shebang)
      [[ $2 ]] || die "argument required for $1"
      fullshebang=1
      shebang=$2
      shift
      ;;
    -e|--edit) edit=1;;
    -p|--editor)
      [[ $2 ]] || die "argument required for $1"
      user_editor=1
      edit=1
      editor=$2
      ;;
    --endopts) shift; break;;
    *) die "invalid option: $1";;
  esac

  shift
done

# check for targets
if ((! $#)); then
  die "no targets specified"
fi

# if -s is used, check if the language is bash, sh, or perl, and set lang
if ((fullshebang)); then
  case $shebang in
    */bash*([!/]) ) lang=bash;;
    */sh*([!/]) )   lang=sh;;
    */perl*([!/]) ) lang=perl;;
  esac

# otherwise, validate lang and set the correct shebang
else
  case $lang in
    bash)   shebang='#!/bin/bash';;
    sh)     shebang='#!/bin/sh';;
    awk)    shebang='#!/bin/awk -f';;
    sed)    shebang='#!/bin/sed -f';;
    perl)   shebang='#!/usr/bin/perl';;
    python) shebang='#!/usr/bin/python';;
    *) die "$lang is not an available preset language"
  esac
fi

# make sure if cron is provided, language is bash or sh
if ((cron)) && [[ $lang != ?(ba)sh ]]; then
  die "cron option is only available for bash or sh"
fi

# iterate over each target file
for file; do
  # if target exists
  if [[ -e $file ]]; then
    # if noclobber is on, set file to the new filename (with .N)
    if ((nc)); then
      file=$(noclobber "$file")

    # otherwise, don't create the file, but add it to be edited for -e
    else
      err "$file already exists"
      toedit+=("$file")
      continue
    fi
  fi

  # write the shebang, and possibly other stuff, to the new file
  {
    printf '%s\n\n' "$shebang"

    case $lang in
      bash)
        printf '%s\n\n' 'shopt -s extglob nullglob'
        ((cron)) && add_path
        ;;
      sh)
        ((cron)) && add_path
        ;;
      perl)
        printf '%s\n%s\n\n' 'use warnings;' 'use strict;'
        ;;
    esac
  } > "$file"

  # make file executable
  chmod +x -- "$file" || err "error making $file executable"
  # add file to list of files to edit
  toedit+=("$file")
done

# if -e is used, open the file(s) in the preferred editor
((edit)) && editor "${toedit[@]}"
